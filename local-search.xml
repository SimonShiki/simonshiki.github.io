<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>别针社区的碎碎念</title>
    <link href="/2022/05/03/clipcommunity/"/>
    <url>/2022/05/03/clipcommunity/</url>
    
    <content type="html"><![CDATA[<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>​        本人加入并活跃的第一个 Scratch 社区是百度的 Scratch 贴吧。由于百度贴吧是一个纯文字类型的论坛，因此吧友互相分享作品时都非常困难，基本都是用百度网盘分享的。<br><img src="https://user-images.githubusercontent.com/59327348/166438509-f2711e86-aa01-4eab-9546-bf24291caa23.png" alt="Snipaste_2022-05-03_16-30-56"></p><p>​        但是百度网盘限速限的非常厉害，因此作品之间的互相传播也受到了限制（官网那时候就算没被封也够慢的了）。于是一部分吧友开始将作品发送到例如好好搭搭，卡搭这样的国内 Scratch 平台上。但是这类平台上或多或少有一些侵权的搬运作品，管理处理也不及时和不尽人意。因此我就在想，能不能自己造一个与卡搭这样的 Scratch 社区呢？正好当时 G-Editor 项目（ClipCC 前身）正值快速更新阶段，迫切需要一个平台分享用 G-Editor 创作的作品，于是别针社区（当时叫 DoForYou）的想法雏形便初步诞生了。</p><h2 id="目的-功能"><a href="#目的-功能" class="headerlink" title="目的 / 功能"></a>目的 / 功能</h2><h3 id="1-自由开放的创作和分享体验"><a href="#1-自由开放的创作和分享体验" class="headerlink" title="1. 自由开放的创作和分享体验"></a>1. 自由开放的创作和分享体验</h3><p>​        我们发现，目前大多数社区都不会将 Scratcher 创作的作品放在首页，甚至要求注册后才能播放作品，这无疑是不利于新人的创作和正常项目的分享的。因此我们希望创建一个足够包容和开放的社区。我们默认在首页展示新人的作品，并持续人工对优秀作品进行筛选，将有创意或优质的作品更久地留在首页内。同时，我们也将社区整体设计的更为简洁，使得创意和分享成为社区的主要组成部分。<br><img src="https://user-images.githubusercontent.com/59327348/166438490-2a947583-888d-4bfe-859d-b2d7ae6ac7de.png" alt="Snipaste_2022-05-03_16-54-36"></p><h3 id="2-从内到外的版权保护设计"><a href="#2-从内到外的版权保护设计" class="headerlink" title="2. 从内到外的版权保护设计"></a>2. 从内到外的版权保护设计</h3><p>​        很多 Scratcher 都有作品被侵权的经历，相信你一定不会喜欢自己作品被搬运到其他地方还不署名这种事。我们认为这与社区的版权意识提醒不到位和作品保护不够完整导致的。因此我们不仅在社区中引入了完整的版权提示，更引入了一套相较于其他社区相比更加安全的源码保护系统。<br><img src="https://user-images.githubusercontent.com/59327348/166438479-7b16b7fe-9a51-4519-a971-feb65d3fa810.png" alt="Snipaste_2022-05-03_16-51-29"></p><p>​        我们自主设计并研发了一套加密的文件格式，该格式不仅采用二进制存储方式，有效减小了项目的 json 数据大小，更能提供及其安全的源码保护体系。同时，我们的管理还会定期在社区内进行审查，以防止漏网之鱼的出现。除此之外，如你发现了有侵权行为的发生，你也可以在作品页面快速举报该作品，我们会在第一时间进行处理。<br><img src="https://user-images.githubusercontent.com/59327348/166438436-97b1a797-3b82-44b5-ac31-007f992d2cef.png" alt="Snipaste_2022-05-03_17-04-39"></p><h3 id="3-更强大的创作工具"><a href="#3-更强大的创作工具" class="headerlink" title="3. 更强大的创作工具"></a>3. 更强大的创作工具</h3><p>​        别针社区使用我们自己基于 Scratch 修改并开发的 ClipCC 作为项目播放器。该编辑器添加了例如自定义返回值，全局自定义函数，HTTPIO，canvas 画板等功能，它们允许你使用 Scratch 创作更为精巧和复杂的作品。同样的，我们也非常欢迎各位高阶开发者们使用更高级的语言开发扩展，为 ClipCC 添加自己想要的功能。<br><img src="https://user-images.githubusercontent.com/59327348/166438411-c2b0b7b2-fb38-4ad1-865c-aadddfde637d.png" alt="Snipaste_2022-05-03_17-20-36"></p><h3 id="4-现代化的网站体验"><a href="#4-现代化的网站体验" class="headerlink" title="4. 现代化的网站体验"></a>4. 现代化的网站体验</h3><p>​        别针社区使用服务端渲染（Server-Side Rendering, SSR）和高性能语言 Go 构建，无论是前端响应速度和后端响应速度在一众社区里都是数一数二的，甚至相比同类社区响应速度提高了70%。同时服务端渲染也可以使得用户的作品能够更容易被搜索引擎捕获，提高作品知名度。<br><img src="https://user-images.githubusercontent.com/59327348/166438363-0550cc42-4c3d-4828-afed-d6543fbf2511.png" alt="Snipaste_2022-05-03_17-30-44"></p><h3 id="5-用爱发电的运营宗旨"><a href="#5-用爱发电的运营宗旨" class="headerlink" title="5. 用爱发电的运营宗旨"></a>5. 用爱发电的运营宗旨</h3><p>​        我们希望创建一个自由开放的 Scratch 社区，我们不打算依赖该社区进行盈利。目前我们的收支全靠成员自行捐款，如有兴趣你也可以通过打赏的方式来帮助我们。我们未来可能会通过外包或讲课的方式赚取运营基本费用，其多出的部分会用于进行社区的活动。</p><h2 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h2><p><em>以下内容仅为当前计划，不代表最终结果，同样不保证会不会在将来进行变动。</em></p><ul><li><input checked="" disabled="" type="checkbox"> 内测日期：2022 年 4 月 23 日</li><li><input disabled="" type="checkbox"> 公测日期：2022 年 6 月中下旬</li><li><input disabled="" type="checkbox"> 正式开放日期：2022 年 8 月</li></ul><h4 id="关于公测以及之后运营的一些想法"><a href="#关于公测以及之后运营的一些想法" class="headerlink" title="关于公测以及之后运营的一些想法"></a>关于公测以及之后运营的一些想法</h4><p>​        在公测阶段，为了限制人流量和保证群体质量，我们会使用邀请码的方式发放账户。而在正式开放阶段，我们会通过答题转正的方式来确保 Scratcher 质量。也许我们之后还会进行国际化工作，谁知道呢？</p><p>​        最后，如果你对别针社区项目感兴趣的话，你可以<a href="https://jq.qq.com/?_wv=1027&k=fuVKotyR">加入</a>我们的官方社区群聊 959825608 获取最新的更新资讯。我们目前开放了一个线上预览站，如果你有兴趣也可以浏览看看最新进度：<a href="https://codingclip.com/%E3%80%82">https://codingclip.com/。</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>谈谈Scratch圈这六年</title>
    <link href="/2022/01/14/scratch-memoir/"/>
    <url>/2022/01/14/scratch-memoir/</url>
    
    <content type="html"><![CDATA[<p>　　曾经一直想给 Scratch 圈写写历史，但一转眼就是 2022 年了，文章还一字未动。不过正巧最近圈内发生了一些事，故乘机写篇文章，讲讲近几年 Scratch 圈近几年的变化好了。<br>　　PS：本篇文章较杂，且可能存在语病。各位读者请多多包涵，感谢！<br><img src="https://u.cubeupload.com/SinanGentoo/3e9cf3dde71190efcb77.jpg" alt="图源 百度贴吧 林琪杰克"></p><h1 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h1><p>　　Scratch 圈的历史很大程度上是少儿编程的发展史。大言不惭的说，本人见证了 Scratch 由小众变为大众的全过程，在这讲讲这几年的一些发展概况。</p><h2 id="2015-2017"><a href="#2015-2017" class="headerlink" title="2015-2017"></a>2015-2017</h2><p>　　本人是被一本我无聊在书架上找到的三无编程启蒙书带入坑的。对当时年幼的我来说，唯一获取相关信息的渠道便是一个写着“DU”字样的蓝色熊掌。在一条条搜索结果中，我点开了第一条链接，从此加入了我的第一个社区 —— Scratch 吧（由此一发不可收拾）。<br><img src="https://u.cubeupload.com/SinanGentoo/579448672775eb4c3bf4.jpg" alt="图源 楠"><br>　　在 Scratch 吧，我首次体会到了<del>沉迷</del>网络的乐趣。吧内的每一个人都可以与其他人分享自己的作品和想法。有人做了一个 Scratch 系统，其他人便一起帮他修改或再创作作品，亦或是借鉴灵感自己创作一个。由于 Scratch 吧所以在的百度贴吧是一个纯文字论坛，因此每个人的作品并不像现在社区一样能够直接发布到网站，而是通过百度网盘分享（当时还不算非常慢，真的），吧友们下载后再体验。我觉得能够坚持这样三年，实际上很大程度上是靠纯兴趣支撑着的。<br>　　当然，Scratch 吧也出现了一些与现在社区同样有的现象 —— 工作室的无序发展。吧内在 2015 年底兴起了工作室创立潮（也是成员迅速增多的时候），因此吧内很快就有了工作室之间的抢人，合作，竞争，或者“间谍”，“抄袭”，“工作室联盟”。不过虽说有类似的“过家家”行为，但在这一时期也涌现了大批优秀创作者和优质作品的出现，这使得 Scratch 吧成为了当时国内最大的交流社区，算得上是 Scratch 吧的“高光时刻”了。<br>　　不过很快，随着这一批 Scratcher 开始长大，Scratch 也成为了它们的“过去式”。于是伴随着 Scratch 吧的衰落，第二个时期到来了。</p><h2 id="2017-2018"><a href="#2017-2018" class="headerlink" title="2017-2018"></a>2017-2018</h2><p>　　稀疏记得在 Scratch 吧处于黄金时代的时候，国内开始刮起了一股少儿编程的风。于是各大 Scratch 社区开始如雨后春笋般出现，Scratch 吧的百度排名也不知从什么时候起开始一点点下降。而当时网易做的编程社区“卡搭”这时也开始被人在 Scratch 吧推荐，于是我便加入了我的第二个社区。<br><img src="https://u.cubeupload.com/SinanGentoo/u4139350932928276462.jpeg" alt="图源 百度图片"><br>　　卡搭与 Scratch 吧最大的不同在于，它是 Scratch 专门设计的。与官网一样，它拥有完善的作品机制，工作室体系和编辑器。因此也吸引了一大批 Scratcher 涌入网易这个新兴社区。<br>　　在这一时期，优秀的作品相比之前出现的更多。大量好玩的游戏与精致的工具作品开始涌现在首页。得益于当时官方的热情，大量的新兴 Scratcher 开始涌入卡搭，Scratch 圈和连同卡搭一起变得更加活跃。<br>　　<strong>但大量优秀作品的出现和创作者的活跃并不能掩盖圈内气氛的变质</strong>。与 Scratch 吧相比，工作室无序化问题愈演愈烈，从而导致整个社区内的不良风气开始滋生。另我记忆犹新的是 2018 年初卡搭官方举行的一场比赛，其中一名前十的参赛选手作品竟直接照搬了官网的优秀作品，甚至进入了决赛阶段都没有人发现。而被揭发后卡搭官方的态度也只是默默撤下了作品。卡搭也自此开始慢慢地被其他社区所超越。</p><h2 id="2019-2020"><a href="#2019-2020" class="headerlink" title="2019-2020"></a>2019-2020</h2><p>　　一只蝙蝠让不仅让学子们享受了一个超长假期，也让 Scratch 圈的格局发生了翻天覆地的改变。一个名为阿儿法营的社区开始迅速崛起。阿儿法营是一个很早就有的平台（历史甚至可追溯到 2010 年），但其线上社区崛起是在 2020 年初。阿儿法营与其他社区的区别在于，阿儿法营拥有可扩展性更高的编辑器，完善的源码保护系统和偏向低龄 Scratcher 的道具设计。<br><img src="https://u.cubeupload.com/SinanGentoo/5855778647727ae12ca8.jpg" alt="图源 阿儿法营官方"><br>　　得益于这些切中国内 Scratcher 们需求的功能和初期官方的积极态度，阿儿法营诞生的优质作品，无论是从数量，质量和产出速度都远远超过上面叙述的两个社区，同时阿儿法营独有的 canvas 和 js 扩展也吸引了不少高阶 Scratcher 入驻。但是阿儿法营的社区氛围问题依然存在并变得更加严重。问题首先出在精华作品评选上。由于 Scratcher 们对精华评定标准存在质疑，因此官方采取了“精华选票”的方法让大家共同选出精华。但这样的方法不仅让各大知名 Scratcher 的主页下面充斥着大量的求票留言，同时也让精华变得更加“唾手可得”。其次由于大量的用户涌入，于是阿儿法营使用了管理员预备役等方式开始在广大 Sctatcher 里招揽管理。该方法前期的确起到了加强管理的作用，但到后期出现了<strong>管理员利用职权徇私</strong>的现象，进一步导致了社区秩序的混乱。在加上阿儿法营最大管理员的一系列迷惑行为，不仅社区质量开始下滑，其管理员本人也遭受到 Scratcher 的广泛攻击。</p><h1 id="Now"><a href="#Now" class="headerlink" title="Now"></a>Now</h1><p>　　如果阿儿法营的衰落是 Scratch 圈的本身问题再加上运营问题的话，那西瓜共创社区则充分体现了什么叫做国内资本公司的少儿编程社区。共创社区似乎在一夜之间兴起，大量优质 Scratcher 迅速流入了共创，优秀作品的增速更是让其他社区望洋兴叹。同时，共创的编辑器不仅做的比阿儿法营的扩展数量更多，播放体验也远远超过了同类的其他编辑器。但共创社区一夜之间的成功<strong>不仅仅是，甚至不是因为其社区本身的优秀</strong>。<br><img src="https://u.cubeupload.com/SinanGentoo/IMG20211222195712.png" alt="共创编辑器违法使用 Turbowarp 源代码证据其一"><br>　　事实上，共创社区在创办后到其他社区大量挖 Scratcher 入驻，甚至直接攻击社区本身来达到提高用户增速的目的。而后共创编辑器被爆出违反开源协议使用 TurboWarp 源代码，官方也仅迫于压力增加了“早就想添加的”致谢名单和开放“已在计划中的”共创源代码，甚至在致谢名单中连其揭露者的名字都没有。<strong>这显然不是一个负责任的社区的行为。</strong> 但是共创社区依旧保持着自己的增长，一点点排挤掉竞争对手，国内 Scratch 圈也陷入了资本的深渊中。<br>　　<strong>但这就意味着我们该放弃希望吗？显然不是。</strong></p><h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p>　　从以上的叙述来看，Scratch 圈的未来似乎希望渺茫。但 Scratch 圈真的没有未来了吗？我想不是。但可以确信的是，<strong>Scratch 圈的未来既不掌握在共创手中，也不掌握在其他社区手中，而掌握在国内广大 Scratcher 手中</strong>。诚然，资本大公司和国内大氛围不是个人能够改变的，但我们能够先从改变我们自己做起。我们不妨停止在无意义的工作室和社区纠纷上纠缠过多，把精力专心投入在作品制作上，回归 Scratch“创作，想象，分享”的本源。<br>　　最后，祝大家 2022 新年快乐！</p>]]></content>
    
    
    
    <tags>
      
      <tag>miscellaneous</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客搭建指南</title>
    <link href="/2022/01/09/how-to-set-up-a-hexo-blog/"/>
    <url>/2022/01/09/how-to-set-up-a-hexo-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><p>　　博客可以为你提供一个你纯粹个人的想法和心得，或是一个分享自己写的文章或与记录自己心情的平台。可是想要搭建一个属于自己的博客却并不简单，高昂的<br>服务器租用费用让人望而却步，同时第三方博客平台的广告也让你无法忍受。难道真的没有一个完美的解决办法吗？下面有请我介绍：<strong>Hexo</strong><br><img src="https://www.webnode.com/blog/wp-content/uploads/2019/04/blog2.png" alt="Blog"></p><span id="more"></span><hr><h3 id="什么是-Hexo"><a href="#什么是-Hexo" class="headerlink" title="什么是 Hexo"></a>什么是 Hexo</h3><p>　　Hexo 是一个快速，简单，免费且功能强大的静态博客框架，他支持主题，插件，同时因为出色的可扩展性与稳定性成为了最佳静态博客框架的不二之选。<br><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRFNpdmy5aj7A1RRHtZNOT6UZee0IkxQk7v-FLazheL2_4WaWJo&usqp=CAU" alt="Hexo"></p><h3 id="什么是静态博客？"><a href="#什么是静态博客？" class="headerlink" title="什么是静态博客？"></a>什么是静态博客？</h3><p>　　静态博客是指不带有任何需要数据库和动态生成网页的程序（举个栗子：PHP）的博客，与动态博客对应，各有优缺点。</p><h3 id="为什么要使用静态博客？动态博客他不香吗？"><a href="#为什么要使用静态博客？动态博客他不香吗？" class="headerlink" title="为什么要使用静态博客？动态博客他不香吗？"></a>为什么要使用静态博客？动态博客他不香吗？</h3><p>　　诸位可能知道 WordPress，Typecho 等博客框架，难道他们不好用吗？首先，动态博客都是指能够动态生成网页内容的博客，但这类博客几乎全部都需要网页服务器带 PHP 解析和数据库，需要一个完整的服务器环境才能够搭建。而正如导语所说，不是每个人都有足够的钱购买价格高昂的服务器，自然动态博客就不适合了。</p><h3 id="那话说回来，静态博客难道就不需要服务器了吗？"><a href="#那话说回来，静态博客难道就不需要服务器了吗？" class="headerlink" title="那话说回来，静态博客难道就不需要服务器了吗？"></a>那话说回来，静态博客难道就不需要服务器了吗？</h3><p>　　<del>你话真多</del>静态博客确实需要服务器，但因为静态博客本身不占用什么资源，于是有很多免费稳定的静态网页服务可以供我们使用，因此就不需要额外购买服务器了。</p><h1 id="配置教程"><a href="#配置教程" class="headerlink" title="配置教程"></a>配置教程</h1><p>　　下面就来介绍一下如何搭建一个博客。本篇文章以 Ubuntu 为操作环境，Windows，macOS 请自寻具体步骤。</p><h2 id="1-安装-Hexo-前的环境配置"><a href="#1-安装-Hexo-前的环境配置" class="headerlink" title="1.安装 Hexo 前的环境配置"></a>1.安装 Hexo 前的环境配置</h2><h3 id="1-安装-Git"><a href="#1-安装-Git" class="headerlink" title="1.安装 Git"></a>1.安装 Git</h3><p>　　由于我们这里要用的是各大编程社区自带的静态网站服务，自然 Git 也必不可少了。要想安装 Git，请输入</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">sudo apt update &amp;&amp; sudo apt-get install git<br></code></pre></td></tr></table></figure><p>等待进度条走完之后输入<code>git version</code>来确保是否安装成功<br><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2616741985,4147970822&fm=26&gp=0.jpg" alt="Git"></p><h3 id="2-安装-NodeJS"><a href="#2-安装-NodeJS" class="headerlink" title="2.安装 NodeJS"></a>2.安装 NodeJS</h3><p>　　Hexo 依赖于 NodeJS 环境，所以在使用 Hexo 之前得先把 NodeJS 装上。由于 Ubuntu 内自带的源并不是最新 NodeJS，很可能会让 Hexo 出现问题，于是我们先要给 NodeJS 加个源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update &amp;&amp; sudo apt-get install software-properties-common curl<br>curl -sL https://deb.nodesource.com/setup_13.x | sudo -E bash -<br>sudo apt-get install nodejs<br></code></pre></td></tr></table></figure><p>安装完成后输入<code>node -v</code>确保安装成功。<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1591407813151&di=4fec905d9eed3a80d96ddefe69da98fb&imgtype=0&src=http://img2.imgtn.bdimg.com/it/u=2829942742,1822803091&fm=214&gp=0.jpg" alt="NodeJS"></p><h2 id="2-开始安装-Hexo"><a href="#2-开始安装-Hexo" class="headerlink" title="2.开始安装 Hexo"></a>2.开始安装 Hexo</h2><p>　　恭喜你！你已经安装好了 Hexo 所需要的前置软件包了，接下来可以开始着手安装 Hexo 了。<br>0.在安装之前，我建议建一个叫做 blog 的文件夹用来存放博客文件以方便管理博客文件。这里请输入<code>mkdir blog &amp;&amp; cd blog</code>来建立并切换到 blog 文件夹。<br>1.输入<code>npm i -g hexo &amp;&amp; npm install hexo-deployer-git --save</code>来开始 Hexo 的安装。等待进度条走完之后输入<code>hexo -v</code>来查看 Hexo 是否安装成功<br>2.输入<code>hexo init</code>来初始化 blog 文件夹，初始化完成之后打开所在的文件夹可以看到以下文件：<br><img src="https://i.niupic.com/images/2020/06/05/8dJA.jpg" alt="file"><br>theme 是主题文件夹，source 是博文存放处，_config.yml 是 Hexo 配置文件，其他的基本上不用动，接下来我们就可以开始配置 Hexo 了。</p><h2 id="3-配置-Hexo"><a href="#3-配置-Hexo" class="headerlink" title="3.配置 Hexo"></a>3.配置 Hexo</h2><h3 id="1-善用-GitHub-Pages"><a href="#1-善用-GitHub-Pages" class="headerlink" title="1.善用 GitHub Pages"></a>1.善用 GitHub Pages</h3><p>　　之前我提到的静态网页服务器就是 GitHub Pages 了。GitHub Pages 是一个由 GitHub 推出的静态网页展示服务。这东西实际上是给 GitHub 项目做官网展示啥的，不过也没说不能用来搭博客吧…🤔<br>PS：国内也有类似于 GitHub Pages 的服务，这里只是拿 GitHub Pages 做演示而已。只要你足够聪明也可以按照教程来把博客传到 Gitee 上去。</p><ol><li>首先请先访问<a href="https://github.com/">GitHub</a>，有账号的登录，没账号的注册。</li><li>创建一个新的 repository（仓库），名字为[你的 GitHub 用户名].github.io。</li><li>回到 Ubuntu 中，输入：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;[你的 Github 用户名]&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;[你的 Github 注册邮箱]&quot;</span><br></code></pre></td></tr></table></figure></li><li>创建并读取 SSH 密钥，输入：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C [你的 Github 注册邮箱]<br>cat id_rsa.pub<br></code></pre></td></tr></table></figure></li><li>把 ssh 放入 GitHub 中（<a href="https://www.cnblogs.com/visugar/p/6821777.html">图片来源</a>）<br><img src="https://visugar.oss-cn-shenzhen.aliyuncs.com/article/setuphexo/settings.png" alt="settings"><img src="https://visugar.oss-cn-shenzhen.aliyuncs.com/article/setuphexo/ssh-key.png" alt="ssh-key"><br>点击”New SSH key”，Title 随便填，key 就填刚才 cat 获取的。添加完之后输入<code>ssh -T git@github.com</code>来确保是否能正确连接。</li><li>使用一个自己喜欢的文本编辑器（例如 nano，vim）编辑 _config.yml，找到最下面 delopy 的那一段，把它替换为以下的内容：<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/[你的 Github 用户名]/[你的 Github 用户名].github.io.git</span><br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure>保存，回到 shell 中。</li><li>接下来就可以上传到 GitHub Pages 了，请输入<code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</code>来自动生成博客文件并上传至 Github Pages，deploy 的过程中要输入你 GitHub 账号的用户名和密码。接下来你只需要访问 http://[你的 Github 用户名].github.io 就能看见你的博客啦！新建文章请使用<code>hexo new &#39;[文章名]&#39;</code>，然后你就可以在 source/_posts 路径下看到你创建的文章啦，编辑完成之后按照前面说的方式自动生成博客文件并上传至 GitHub Pages，在浏览器刷新就能看到你的文章了。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>tutorial</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ClipCC - 轻量，强大的二开Scratch编辑器</title>
    <link href="/2022/01/09/clipcc/"/>
    <url>/2022/01/09/clipcc/</url>
    
    <content type="html"><![CDATA[<p>我在 2020 年开始尝试制作一个 Scratch 修改版（我将它命名为 ClipCC），希望你能喜欢它!<br><img src="https://s3.jpg.cm/2021/09/20/IEfdwG.jpg"></p><h1 id="ClipCC-改变了什么"><a href="#ClipCC-改变了什么" class="headerlink" title="ClipCC 改变了什么"></a>ClipCC 改变了什么</h1><h2 id="一些界面优化"><a href="#一些界面优化" class="headerlink" title="一些界面优化"></a>一些界面优化</h2><p><img src="https://s3.jpg.cm/2021/09/20/IE4N4S.png"><br>ClipCC 改变了类别栏的显示风格，以解决在某些情况下类别栏中的文字显示不完整的问题。我们还删除了一些在大多数情况下不会使用的菜单栏项目，使编辑器更加整洁。</p><h2 id="自定义布局样式"><a href="#自定义布局样式" class="headerlink" title="自定义布局样式"></a>自定义布局样式</h2><p><img src="https://s3.jpg.cm/2021/09/20/IE4SMW.png"><br>为了让一些从 Scratch2.0 升级到 Scratch3.0 的 Scratcher 们更快地适应 Scratch3.0，ClipCC 增加了 Scratch2 样式的布局。</p><h2 id="一些有关互联网的扩展"><a href="#一些有关互联网的扩展" class="headerlink" title="一些有关互联网的扩展"></a>一些有关互联网的扩展</h2><p><img src="https://s3.jpg.cm/2021/09/20/IEfVsD.png"><br>我们增加了 HTTP IO 和 JSON 扩展，允许用户在自己的项目中直接使用互联网资源，你甚至可以制作自己的百科全书应用或浏览器!</p><h2 id="文本打印"><a href="#文本打印" class="headerlink" title="文本打印"></a>文本打印</h2><p>出于向下兼容和降低文本打印难度的原因，ClipCC 添加了一些用于在舞台上打印文本和绘制矩形的积木。<br><img src="https://s3.jpg.cm/2021/09/20/IEfcJT.png"></p><h2 id="暗黑模式"><a href="#暗黑模式" class="headerlink" title="暗黑模式"></a>暗黑模式</h2><p><img src="https://s3.jpg.cm/2021/09/20/IE4skH.png"><br><img src="https://s3.jpg.cm/2021/09/20/IE4k7f.png"><br>黑暗模式是一种“戏剧性”的新外观，可帮助您专注于在黑暗中进行创作，营造无干扰的氛围。可以在设置里面启用它！ （默认跟随系统）</p><h2 id="未知模块转换"><a href="#未知模块转换" class="headerlink" title="未知模块转换"></a>未知模块转换</h2><p><img src="https://s6.jpg.cm/2021/11/12/IaeefU.png"><br><img src="https://s6.jpg.cm/2021/11/12/IaelOO.png"><br>由于 Scratch3 的一些奇妙的限制，包含自家积木的 Scratch 修改版编辑器不能直接相互转换，这使得创作者无法在各个社区快速发布他们的作品。ClipCC 增加了一种将未知积木转换为未定义的自定义积木的方法，这样它们就可以正常打开，使作品的迁移更容易。</p><h2 id="可变舞台帧率"><a href="#可变舞台帧率" class="headerlink" title="可变舞台帧率"></a>可变舞台帧率</h2><p><img src="https://s6.jpg.cm/2021/11/12/Iae8p8.gif"><br>ClipCC 提供了一个选项，允许用户控制屏幕刷新的频率，这可以使一些游戏或动画更加丝般顺畅。</p><h2 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h2><p><strong>原版:</strong><br><img src="https://s3.jpg.cm/2021/09/20/IE4g8e.png"><br><strong>ClipCC:</strong><br><img src="https://s3.jpg.cm/2021/09/20/IE4BMk.png"><br>ClipCC 消除了 Blockly 关于拖动背景触发全面刷新和添加工作区缓存的问题。在有很多块的情况下，每次刷新都要花很多时间，而在拖动块的情况下，刷新就没有必要了。当打开大型项目时，帧率从优化前的 800-1000ms 下降到 100ms。在有 4000 个积木的字符之间切换的速度也从 1000ms 降到了 350ms。</p><h2 id="杂项优化"><a href="#杂项优化" class="headerlink" title="杂项优化"></a>杂项优化</h2><p>除了上面列出的主要功能外，我们还增加了一些零散的小功能，如取消了克隆/链表限制，增加了一些高级算术积木、加速模式控制积木和操作系统侦测积木，优化了界面等。如有需要，请到预览网站上亲自体验!</p><h2 id="我们现在在开发什么"><a href="#我们现在在开发什么" class="headerlink" title="我们现在在开发什么"></a>我们现在在开发什么</h2><h2 id="一个全新的扩展系统"><a href="#一个全新的扩展系统" class="headerlink" title="一个全新的扩展系统"></a>一个全新的扩展系统</h2><p><img src="https://s3.jpg.cm/2021/09/20/IEfUzE.png"><br>与官方的 Scratch 扩展不同，ClipCC 扩展允许你以 webpack 包的形式直接加载到编辑器中。因为这个功能还在开发中，所以 API 的数量有限，如果你有什么想法，请联系我们。</p><h2 id="编译器支持"><a href="#编译器支持" class="headerlink" title="编译器支持"></a>编译器支持</h2><p><img src="https://s6.jpg.cm/2021/11/12/Iae5CH.gif"><br>ClipCC 支持将 Scratch 积木转换为原生 Javascript 代码来执行。得益于地球上最快的脚本语言执行器（V8），ClipCC 的执行效率将比原版提高几个数量级，为更多需要高性能的项目（例如 3D 游戏）提供支持。</p><h2 id="全局自定义积木"><a href="#全局自定义积木" class="headerlink" title="全局自定义积木"></a>全局自定义积木</h2><p><img src="https://s3.jpg.cm/2021/09/20/IEfuIQ.gif"><br>该功能允许你在不同的角色中使用相同的自定义积木，以此来减少代码量并优化性能。</p><h2 id="带返回值的自定义积木"><a href="#带返回值的自定义积木" class="headerlink" title="带返回值的自定义积木"></a>带返回值的自定义积木</h2><p><img src="https://s6.jpg.cm/2021/11/13/Iavt7h.png"><br>这个功能可以帮助你更好地编写与递归和数学运算有关的作品，也可以帮助那些想让作品更加简洁的 Scratcher 们！</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>类似于 JavaScript 代码和 Scratch 积木的双向转换（类似于 leopoard.js），基于 FileSystem API 的直接本地保存，高清画笔等。</p><h1 id="我怎么才能体验它呢"><a href="#我怎么才能体验它呢" class="headerlink" title="我怎么才能体验它呢?"></a>我怎么才能体验它呢?</h1><p>你可以通过<a href="https://codingclip.com/editor/dev/canary">这里</a>来访问预览站。 您也可以通过 GitHub 找到离线版本。只需搜索“clipcc-desktop”即可。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何实现一个带JIT的Scratch虚拟机</title>
    <link href="/2022/01/09/how-to-make-a-jit-scvm/"/>
    <url>/2022/01/09/how-to-make-a-jit-scvm/</url>
    
    <content type="html"><![CDATA[<p>众所周知，由于 Scratch 原生虚拟机的实现非常暴力，因此 Scratch 的虚拟机一直是众多有高性能需求的 Scratch 作品的噩梦。你甚至能看到在极少的循环内执行延迟就已达到了惊人的 300ms。为此，各路 Scratcher 争相拿出了解决方案（例如 forkphorus, TurboWarp 等），其中最普遍的思路就是使用浏览器自带的 JavaScript 引擎来把积木转换成原生代码再运行。（当然也有用其他语言重写虚拟机的，本篇不细讲）本文将结合本人编写 JIT 功能的经验，谈谈如何在原有的 Scratch 虚拟机上添加一个 JIT 功能。<br><img src="https://s6.jpg.cm/2021/11/12/Iae5CH.gif"><br><em>PS：本文仅提供思路，具体代码需要各位读者自行实践。</em></p><h2 id="怎么生成"><a href="#怎么生成" class="headerlink" title="怎么生成"></a>怎么生成</h2><p>我们分析源码可得，Scratch 的运行逻辑大概是这样的：</p><pre><code class="mermaid" >graph LR    A(Runtime) -->|从 target 读取 block 创建| B(Thread - FRESH)    B -->|开始运行| C[Thread - RUNNING]    C -->G[Execute]    C -->|进入“休息”时间| D[Thread - YIELD_TICK]    D -->|完成该线程的使命| E[Thread - DONE]    F(sequencer) -->|进行调度管理| C    F -->|进行调度管理| D    F -->|进行调度管理| E</code></pre><p>由以上流程我们可知，我们要抢先在线程进入运行环节前生成相关代码，所以我们要在生成完新鲜的 Thread 后立刻开始生成。<br>生成的最基本思路便是取出当前 Thread 的积木容器，并挨个遍历积木并生成相应代码。比如走( )步积木的实现就理所应当的如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Motion</span> </span>&#123;<br>　　<span class="hljs-comment">// ...</span><br>　　moveSteps (args, util) &#123;<br>　　　　<span class="hljs-keyword">const</span> steps = Cast.toNumber(args.STEPS);<br>　　　　<span class="hljs-keyword">const</span> radians = MathUtil.degToRad(<span class="hljs-number">90</span> - util.target.direction);<br>　　　　<span class="hljs-keyword">const</span> dx = steps * <span class="hljs-built_in">Math</span>.cos(radians);<br>　　　　<span class="hljs-keyword">const</span> dy = steps * <span class="hljs-built_in">Math</span>.sin(radians);<br>　　　　util.target.setXY(util.target.x + dx, util.target.y + dy);<br>　　&#125;<br>　　<span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>按照上面的代码生成，相信明眼人都能看出问题。我们生成的代码返回的是字符串而不是函数，因此参数是不能直接传过去的。所以我们的思路是使用一个函数来实现对参数的处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Motion</span> </span>&#123;<br>　　<span class="hljs-comment">//...</span><br>　　<span class="hljs-attr">motion_movesteps</span>: <span class="hljs-function">(<span class="hljs-params">args</span>) =&gt;</span> &#123;<br>        　　<span class="hljs-keyword">const</span> steps = args.STEPS;<br>        　　<span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">　　　　　　const radians = 　MathUtil.degToRad(90 - util.target.direction);</span><br><span class="hljs-string">　　　　　　const dx = <span class="hljs-subst">$&#123;steps&#125;</span> * Math.cos(radians);</span><br><span class="hljs-string">　　　　　　const dy = <span class="hljs-subst">$&#123;steps&#125;</span> * Math.sin(radians);</span><br><span class="hljs-string">　　　　　　util.target.setXY(util.target.x + dx, util.target.y + dy);</span><br><span class="hljs-string">　　　　`</span><br>&#125;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>至于内部运行需要的 util，则在生成时使用前缀的方式，运行时作为参数传入即可。</p><h3 id="运行时刷新"><a href="#运行时刷新" class="headerlink" title="运行时刷新"></a>运行时刷新</h3><p>像以上代码，运行时间短的积木可以忽略，但运行时间长就会阻塞整个编辑器，造成无休止的卡顿。为此我们需要引入<code>Generator Function</code>来防止这种情况的出现。<br>GeneratorFunction 是一种允许控制运行流程的函数，在函数内可以使用<code>yield [value];</code>的方式暂停函数的运行并等待调用方的下一步操作。<br>于是我们就可以将控制积木类的重复执行以以下的方式呈现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Control</span> </span>&#123;<br>　　<span class="hljs-attr">control_forever</span>: <span class="hljs-function">(<span class="hljs-params">args</span>) =&gt;</span> &#123;<br>　　　　<span class="hljs-keyword">const</span> SUBSTACK = args.SUBSTACK;<br>　　　　<span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">　　　　　　while(true) &#123;</span><br><span class="hljs-string">　　　　　　　　<span class="hljs-subst">$&#123;SUBSTACK&#125;</span></span><br><span class="hljs-string">　　　　　　　　yield;</span><br><span class="hljs-string">　　　　　　&#125;</span><br><span class="hljs-string">　　　　`</span><br>　　&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后在运行时由调度器进行调度即可, REPORTER 同理。</p><h2 id="没有对应-JIT-代码的积木"><a href="#没有对应-JIT-代码的积木" class="headerlink" title="没有对应 JIT 代码的积木"></a>没有对应 JIT 代码的积木</h2><p>本着最大化效率和确保兼容性的理念，我们不可能为了一个线程中的一个没有对应 JIT 代码的积木而放弃整个线程的编译。所以我们需要在生成时记录下这个没有对应 JIT 代码的积木并跳转到下一个有对应 JIT 代码的积木进行编译。</p><h2 id="不刷新屏幕的自定义积木"><a href="#不刷新屏幕的自定义积木" class="headerlink" title="不刷新屏幕的自定义积木"></a>不刷新屏幕的自定义积木</h2><p>我们可以通过在生成该自定义积木时传参，控制要不要 yield 即可。<br>（PS：不会真的有人在定义里写高耗时积木吧）</p><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><p>像 Scratch 这种按积木执行的模式是非常难在 JIT 在确保实时热更新的。因此我们只能在每次执行完这个编译片段（或遇到 yield 的情况）时返回当前的 blockID 并检测更新才能一定程度上确保热更新。由于 Scratch 是单线程的，且只有在高耗时积木中才会使用 yield（低耗时积木你感受不出来（不是），因此该问题不会有太大影响。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>以上仅为目前本人的实现思路，因此很可能存在谬误。如果你在编写过程中发现存在错误，请发邮件予以指正！</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://steve-xmh.github.io/blog/2020/05/16/scratchvmjit/">SteveXMH - 关于如何优化 Scratch 虚拟机的运行速度思路</a><br><a href="https://github.com/TurboWarp/scratch-vm/">TurboWarp 源码</a><br><a href="https://github.com/Clipteam/clipcc-vm/">ClipCC 源码</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>tutorial</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown - 简单富文本语言介绍</title>
    <link href="/2021/01/10/markdown/"/>
    <url>/2021/01/10/markdown/</url>
    
    <content type="html"><![CDATA[<p>　　大家好，我是司南。随着时代的进步和发展，html或者是自带富文本编辑都变得越来麻烦或臃肿了。因此，人们发明了一种新的，简单易学的，通用的富文本语言：<strong>Markdown</strong>。<span id="more"></span></p><h2 id="什么是Markdown"><a href="#什么是Markdown" class="headerlink" title="什么是Markdown"></a>什么是Markdown</h2><p>　　Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。<br>　　Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho（就是我现在用的这个博客啦）。<br><img src="https://pic1.zhimg.com/80/v2-4dc882e245ca3af70f2e7361d5bef282_720w.jpg"></p><h2 id="Markdown-初阶使用"><a href="#Markdown-初阶使用" class="headerlink" title="Markdown 初阶使用"></a>Markdown 初阶使用</h2><p>　　对于一般人写博客来讲，Markdown其实用到的并不多，下面我来讲讲最基本的Markdown语法。</p><h3 id="1-粗体"><a href="#1-粗体" class="headerlink" title="1. 粗体"></a>1. 粗体</h3><p>粗体只需要将需要加粗的文本两边加上两个*就好了，就像这样：<code>**我要变粗！**</code>，效果就像这样： <strong>我要变粗！</strong> 怎么样，是不是很简单？</p><h3 id="2-斜体"><a href="#2-斜体" class="headerlink" title="2.斜体"></a>2.斜体</h3><p>斜体更简单，只需要将需要加粗的文本两边加上一个*就好了，就像这样：<code>*我要变弯！*</code>，效果就像这样：<br> <em>我要变弯！</em> <del>（我怀疑我在ghs）</del></p><h3 id="3-删除线"><a href="#3-删除线" class="headerlink" title="3.删除线"></a>3.删除线</h3><p>不多说，看示例：</p><figure class="highlight haml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs haml">~~我能吞下玻璃而不伤身体~~<br></code></pre></td></tr></table></figure><p>效果如下：<br><del>我能吞下玻璃而不伤身体</del></p><h3 id="4-一级到六级标题"><a href="#4-一级到六级标题" class="headerlink" title="4.一级到六级标题"></a>4.一级到六级标题</h3><p>这个只需要在文本前加#号与空格就行了，下面举个栗子：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 我是一号标题<br>## 我是二号标题<br>### 我是三号标题<br>#### 我是四号标题<br>##### 我是五号标题<br>###### 我是六号标题<br></code></pre></td></tr></table></figure><p>效果如下：</p><h1 id="我是一号标题"><a href="#我是一号标题" class="headerlink" title="我是一号标题"></a>我是一号标题</h1><h2 id="我是二号标题"><a href="#我是二号标题" class="headerlink" title="我是二号标题"></a>我是二号标题</h2><h3 id="我是三号标题"><a href="#我是三号标题" class="headerlink" title="我是三号标题"></a>我是三号标题</h3><h4 id="我是四号标题"><a href="#我是四号标题" class="headerlink" title="我是四号标题"></a>我是四号标题</h4><h5 id="我是五号标题"><a href="#我是五号标题" class="headerlink" title="我是五号标题"></a>我是五号标题</h5><h6 id="我是六号标题"><a href="#我是六号标题" class="headerlink" title="我是六号标题"></a>我是六号标题</h6><p><del>（虽然很不想吐槽六号标题连一般文本都不如了）</del></p><h3 id="4-插入链接与图片"><a href="#4-插入链接与图片" class="headerlink" title="4.插入链接与图片"></a>4.插入链接与图片</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">[这是一个链接，点我进入某<span class="hljs-number">404</span>小公司搜索引擎](https:<span class="hljs-regexp">//</span>www.google.com/)<br>![这是关于图片的描述，罗小黑太可爱了awsl](https:<span class="hljs-regexp">//i</span>.niupic.com<span class="hljs-regexp">/images/</span><span class="hljs-number">2020</span><span class="hljs-regexp">/03/</span><span class="hljs-number">07</span>/<span class="hljs-number">6</span>YNU.jpg)<br></code></pre></td></tr></table></figure><p><a href="https://www.google.com/">这是一个链接，点我进入某404小公司搜索引擎</a><br><img src="https://i.niupic.com/images/2020/03/07/6YNU.jpg" alt="这是关于图片的描述，罗小黑太可爱了awsl"><br>PS：图片大多依赖图床，你可以使用Typecho或者博客程序自带的附件来直接上传，也可以通过图床（例如<a href="https://sm.ms/">sm.ms</a>）来上传并插入</p><h2 id="Markdown-高级用法"><a href="#Markdown-高级用法" class="headerlink" title="Markdown 高级用法"></a>Markdown 高级用法</h2><p>以上应该就能满足绝大部分的富文本处理了，接下来我将给出个人整理的高级版Markdown使用方法（高能预警）：</p><h3 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h3><p>在内容前后加三个***就是斜体加粗。</p><ul><li><strong>例子</strong></li></ul><p><em><strong>斜体加粗</strong></em></p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>分割线就是在空白的一行连续输入三个*或者-。</p><ul><li><strong>例子</strong></li></ul><hr><h3 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h3><p>区块引用是空行输入三个```，最后再用三个点号结束，中间包含的内容就是区块引用。（第一个三个点之前可以加语言标识符，部分渲染器可以自动语法高亮）</p><ul><li><strong>例子</strong></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs"><br>这是引用测试<br><br>hhhh<br><br></code></pre></td></tr></table></figure><hr><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><p>如果只是一行代码，使用一个`包含起来即可，如果是多行代码，建议用区块引用。</p><ul><li><strong>例子</strong></li></ul><p><code>这是代码</code></p><hr><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>在每行开头使用一个*、+、-，再加上一个空格，就会形成无序列表。</p><ul><li><strong>例子</strong></li></ul><ul><li><p>1</p></li><li><p>2</p></li></ul><hr><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>使用数字加.号，再空格，加上后面的内容，就会形成有序列表。</p><ul><li><strong>例子</strong></li></ul><ol><li><p>123</p></li><li><p>369</p></li><li><p>456</p></li><li><p>489</p></li></ol><hr><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表格按照以下三部分组成：</p><ul><li><p>表头</p></li><li><p>占位分隔</p></li><li><p>内容</p></li><li><p>符号：|，- |—|(表示标题)</p></li></ul><ul><li><strong>例子</strong></li></ul><table><thead><tr><th>星期一</th><th>星期二</th><th>星期三</th><th>星期四</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><hr><h2 id="扩展篇"><a href="#扩展篇" class="headerlink" title="扩展篇"></a>扩展篇</h2><p>严格来说这不算标准的Markdown，但很多渲染器都支持这些新的，我就在这列举一些吧。（以下个人博客无法渲染，因此使用者请找兼容这些语法的渲染器去使用）</p><h3 id="LaTeX"><a href="#LaTeX" class="headerlink" title="LaTeX"></a>LaTeX</h3><p>$ 表示行内公式：</p><p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。<br>10.2. $$ 表示整行公式：</p><p>$$\sum_{i=1}^n a_i=0$$<br>$$f(x_1,x_x,\ldots,x_n)= x_1^2+ x_2^2+ \cdots + x_n^2 $$<br>$$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$$</p><p>访问 MathJax 参考更多使用方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>tutorial</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
